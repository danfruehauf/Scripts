#!/bin/bash
#
# span-files.sh - a utility to span/spread files across multiple smaller HDs
# Copyright (C) 2016 Dan Fruehauf <malkoadan@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#

declare -r MAX_DEST_FILL=0.9 # fill up to 90% on destinations

# return index file
# $1 - tmp directory for operation
_get_index_file() {
	echo "$1/index"
}

# return spanning files prefix
# $1 - tmp directory for operation
_get_spanning_files_prefix() {
	echo "$1/list."
}

# returns available space on destination directory
# $1 - destination directory
_get_part_size() {
	local dir=$1; shift
	(echo -n "1024 * $MAX_DEST_FILL * "; df --output=size --block-size=1KB $dir | tail -1) | bc -l | cut -d. -f1
}

# create an index of files to copy. basically just create a list of files and
# their sizes which will look like:
# SIZE1 FILENAME1
# SIZE2 FILENAME2
# $1 - tmp directory for operation
# $2 - source directory to index
# "$@" - list of destination directories (not used in this function)
index() {
	local tmp_dir=$1; shift
	local source_dir=$1; shift
	local index_file=`_get_index_file $tmp_dir`
	echo -n "Indexing sizes of files in directory '$source_dir'..."
	(cd $source_dir && find . -type f -follow -exec stat --printf "%s %n\n" {} \;) > $index_file
	echo "Done!"
}

# takes as an input an index of files (generated by index()) and outputs
# multiple files that will define how to span the files across multiple devices
# $1 - tmp directory for operation
# $2 - source directory to index (not used in this function)
# "$@" - list of destination directories
span() {
	local tmp_dir=$1; shift
	local source_dir=$1; shift

	local dst_dir=$1; shift
	local -i part_size=`_get_part_size $dst_dir`

	local index_file=`_get_index_file $tmp_dir`
	local spanning_files_prefix=`_get_spanning_files_prefix $tmp_dir`

	local -i current_part_size=0
	local -i part_nr=1
	IFS=$'\n'
	for line in `cat $index_file`; do
		unset IFS
		sz=${line%% *}
		file=${line#* }

		local -i tmp_current_part_size=$current_part_size+$sz
		if [ $tmp_current_part_size -ge $part_size ]; then
			echo "Finalizing part '$part_nr' ('$dst_dir') with size '$current_part_size' (max size '$part_size')"
			let part_nr=$part_nr+1
			current_part_size=0

			local dst_dir=$1; shift
			part_size=`_get_part_size $dst_dir`
		fi

		echo "$file" >> ${spanning_files_prefix}${part_nr}
		let total_size=$total_size+$sz
		let current_part_size=$current_part_size+$sz
	done
	echo "Finalizing part '$part_nr' ('$dst_dir') with size '$current_part_size' (max size '$part_size')"

	echo "Total of '$total_size' bytes split into '$part_nr' parts"
}

# given a temporary directory for operation which contains lists of files to
# copy, this function will do the actual copying using rsync
# $1 - tmp directory for operation
# $2 - source directory
# "$@" - destination directories
copy() {
	local tmp_dir=$1; shift
	local src_dir=$1; shift
	local spanning_files_prefix=`_get_spanning_files_prefix $tmp_dir`

	local spanning_file
	for spanning_file in ${spanning_files_prefix}*; do
		local dst_dir=$1; shift
		if [ x"$dst_dir" != x ]; then
			echo "rsync -v --files-from=$spanning_file $src_dir $dst_dir"
		else
			echo "Not enough destination directories specified"
			return 1
		fi
	done
}

# prints usage
usage() {
	echo "Usage: $0 [OPTIONS]... -o OPERATION -s SOURCE_DIR"
	echo "Copies files from source directory to smaller destination directories."
	echo "
Options:
  -s, --source               Source directory
  -d, --destination          Destination directories (probe sizes too)
  -S, --size                 Split into equal sizes
  -o, --operation            Operation type, one of:
                              * index - Generate an index of files and
                                their sizes
                              * span - Prepare lists of files for copying
                              * copy - Use lists of files and copy to
                                destination directories
                              * all - All of the above
  -t, --tmpdir               Temp directory for operation. Allocate one before
                             running this script or simply use . (current directory)"
	exit 2
}

main() {
	local tmp_getops
	tmp_getops=`getopt -o hs:d:S:o:t: --long help,source:,destination:,size:,operation:,tmpdir: -- "$@"`
	[ $? != 0 ] && usage

	eval set -- "$tmp_getops"
	local src_dir dst_dirs operation tmp_dir
	local -i size=0

	# parse the options
	while true ; do
		case "$1" in
			-h|--help) usage;;
			-s|--source) src_dir="$2"; shift 2;;
			-d|--destination) dst_dirs="$dst_dirs $2"; shift 2;;
			-S|--size) size="$2"; shift 2;;
			-o|--operation) operation="$2"; shift 2;;
			-t|--tmpdir) tmp_dir="$2"; shift 2;;
			--) shift; break;;
			*) usage;;
		esac
	done

	[ x"$src_dir" = x ] && usage
	[ x"$dst_dirs" = x ] && usage
	[ x"$operation" = x ] && usage
	[ x"$tmp_dir" = x ] && usage

	if [ $size -ne 0 ]; then
		size=`echo "$size * $MAX_DEST_FILL" | bc -l | cut -d. -f1`
		# override size calculation function
		_get_part_size() {
			echo $size
		}
		echo "Splitting into even parts of '$size' bytes each"
	fi

	mkdir -p $tmp_dir
	if [ "$operation" = "all" ]; then
		operation="index span copy"
	fi

	local op
	for op in $operation; do
		if ! $op $tmp_dir $src_dir $dst_dirs; then
			echo "Operation '$op' failed"
		fi
	done
}

main "$@"
